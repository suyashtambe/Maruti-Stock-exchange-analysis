# -*- coding: utf-8 -*-
"""SDS_Apna Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12wz--6bkQV3w-wlDDRNq3du2MOCqnQS3
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sb 
import random 
df =pd.read_csv("/content/SDS dataset Raw CSV.csv")

df.index=df.iloc[:,0]

df

input=df['open']
output=np.array(df['high'])

df.boxplot(['high'])
plt.savefig('Boxplot.png',dpi=300)

plt.boxplot(output)
plt.savefig('Boxplot.png',dpi=300)
plt.show()

df.boxplot(['open'])

df.hist(['high'])

#LINEAR  REGRESSION.
def weights(input,output):
  mean_x=np.mean(input)
  mean_y=np.mean(output)

  #compute theta 1
  theta_1=(np.sum((input-mean_x)*(output-mean_y)))/(np.sum((input-mean_x)**2))

  #compute theta 0
  theta_0=mean_y-theta_1*mean_x
  print("Theta_0 and Theta_1 are {} and {} respectively".format(theta_0,theta_1))
  return[theta_0,theta_1]

#Using theta_1 and theta_0 to get y_cap (i.e linear regression model)
t_0,t_1=weights(input,output)
y_bar=t_0+(t_1*input)
y_bar

#error
error=output-y_bar
error

#scatter plot to check the heteroscedasticity
plt.scatter(error,input)
plt.savefig('scatterplot.png',dpi=300)
plt.show()

output_sd=np.std(output)

## computing (error)^2 i.e rss using LR
rss=np.sum((output-y_bar)**2)
rss

#Computing MSE
mse=np.mean((output-y_bar)**2)
mse

# computing rmse
rmse=mse*(1/2)
rmse

#compute mae
mae=np.mean(abs(y_bar-output))
mae

#compute mape
mape=np.mean(abs(output-y_bar)/output)*100
mape

# output mean(don't add this to ppt)
mean_output=np.mean(output)
mean_output

#ssd
ssd=np.sum((output-mean_output)**2)
ssd

#R_square (coefficient of determination)
R_square=1-(rss/ssd)
R_square

def picker(arr,sample_size):
  l=[]
  a=len(arr)
  for i in range(sample_size):
    l.append(arr[random.randint(0,a-1)])
  return l

sd=[]
m=[]
h=150 #sample size
n=100 #number of sample
for j in range(n):
  m.append(np.mean(picker(output,h)))
  sd.append(np.std(picker(output,h)))

population_mean=np.mean(m)
population_sd=np.mean(sd)

print(population_mean)
print(population_sd)
print(mean_output)
print(output_sd)

plt.plot(m)

plt.plot(sd)

sigma=np.std(output)

x=np.mean(output)+3*sigma

newoutput=output

count=0
for i in range(3182):
  if newoutput[i]>=x:
    newoutput[i]=np.median(output)
    count=count+1

count

plt.boxplot(newoutput)

sigma=np.std(newoutput)
yx=np.mean(newoutput)+3*sigma

count=0
for i in range(3182):
  if newoutput[i]>=yx:
    newoutput[i]=np.median(output)
    count=count+1

df["open"]=newoutput

plt.boxplot(newoutput)

import numpy as np

def find_outliers(data):
  q1, q3 = np.percentile(data, [25, 75])
  iqr = q3 - q1
  lower_bound = q1 - (1.5 * iqr)
  upper_bound = q3 + (1.5 * iqr)
  outliers = [x for x in data if x < lower_bound or x > upper_bound]
  return outliers

outlier = find_outliers(newoutput)
outlier

count1=0
for i in range(len(newoutput)):
  for j in outlier:
    if newoutput[i]==j:
      newoutput[i]=np.median(input)
      count1=count1+1

print(count1)



df.describe()

df.to_csv("replaced.csv")

df.describe

df.to_csv("replaced.csv")

plt.boxplot(outlier)

def weights(input,output):
  mean_x=np.mean(input)
  mean_y=np.mean(output)

  #compute theta 1
  theta_1=(np.sum((input-mean_x)*(output-mean_y)))/(np.sum((input-mean_x)**2))

  #compute theta 0
  theta_0=mean_y-theta_1*mean_x
  print("Theta_0 and Theta_1 are {} and {} respectively".format(theta_0,theta_1))
  return[theta_0,theta_1]

t_0,t_1=weights(input,output)
y_bar=t_0+(t_1*input)
y_bar
